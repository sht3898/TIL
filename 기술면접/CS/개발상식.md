# 객체 지향 프로그래밍(Object Oriented Programming)

* 객체 지향 프로그래밍 이전의 프로그래밍 패러다임 => 컴퓨터 중심

* 객체 지향 프로그래밍 => 인간 중심적 프로그래밍

* 현실 세계의 사물들을 객체라고 보고, 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 => **추상화**
* 이미 작성한 코드에 대한 **재사용성**이 높음
* 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 **버그 발생이 줄어듦**
* 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 **생산성이 높아지게 됨**
* 객체 단위로 코드가 나눠져 작성되기 때문에 **디버깅이 쉽고 유지보수에 용이**
* 데이터 모델링 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을보다 명확하게 파악하여 프로그래밍 가능
* 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 **overhead**가 발생 =>  하드웨어의 발전으로 많은 부분 보완됨
* 단점 => 객체가 상태를 갖음. 변수가 존재하고 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킴 => 함수형 패러다임이 주목 받음

## 객체 지향적 설계 원칙

1. SRP(Single Responsibility Principle): 단일 책임 원칙
   * 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
2. OCP(Open-Closed Principle): 개방-폐쇄 원칙
   * 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
3. LSP(Liskov Substitution Principle): 리스코프 교환 법칙
   * 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
   * 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. DIP(Dependency Inversion Principle): 의존 역전 원칙
   * 고수준 모듈을 저수준 모듈의 구현에 의존해서는 안된다.



## 정의

* 객체 지향의 가장 기본은 객체, 객체의 핵심은 기능을 제공하는 것
* 객체를 정의할 때 사용하는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않음
* 이러한 기능들을 오퍼레이션이라 부름 => 객체는 **오퍼레이션**으로 정의됨



![img](https://t1.daumcdn.net/cfile/tistory/21582237577609F030)

### Reference

* [객체 지향에 대한 얕은 이해](https://asfirstalways.tistory.com/177)



# RESTful API

> 월드 와이드 웹(WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴

* `REST`란 REpresentational State Transfer의 약자, ful은 형용사형 어미
* `REST`가 디자인 패턴이다, 아키텍쳐다 많은 이야기가 존재하는데, 하나의 아키텍쳐로 볼 수 있다.
* REST는 `Resource Oriented Architecture`이다. API 설계의 중심에 자원(Resource)이 있고, HTTP Method를 통해 자원을 처리하도록 설계하는 것



## REST 6가지 원칙

* Uniform Interface(유니폼 인터페이스)
  * URL로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍쳐 스타일
* Stateless(무상태성)
  * 작업을 위한 상태정보를 따로 저장하고 관리하지 않음
  * 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됨
  * 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해짐
* Caching(캐시 가능)
  * REST는 HTTP라는 기준 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용 가능 => HTTP가 가진 캐싱 기능이 적용 가능
  * HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능
* Self-descriptiveness(자체 표현 구조)
  * REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있음
* Client-Server 구조
  * REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됨
* Hierarchical system(계층형 구조)
  * REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.
* Code on demand

## RESTful 하게 API를 디자인 한다는 것을 무엇을 의미하는가

1. **리소스**와 **행위**를 명시적이고 직관적으로 분리
   * 리소스는 `URI`로 표현되는데 리소스가 가리키는 것은 `명사`로 표현되어야 한다.
   * 행위는 `HTTP Method`로 표현되고, `GET(조회)`, `POST(생성)`, `PUT(기존 entity 전체 수정)`, `PATCH(기존 entity 일부 수정)`, `DELETE(삭제)`을 분명한 목적으로 사용한다.
2. Message는 Header와 Body를 명확하게 분리해서 사용
   * Entity에 대한 내용은 Body에 담는다.
   * 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 header에 담는다.
   * header와 body는 http header와 http body로 나눌 수도 있고, http body에 들어가는 json 구조로 분리할 수도 있다.
3. API 버전을 관리
   * 환경은 항상 변하기 때문에 API의 signature가 변경될 수도 있음에 유의
   * 특정 API를 변경할 때는 반드시 하윟환성을 보장해야 함
4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 함
   * 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json으로 보내든, 둘 다 form-data 형식으로 보내든 하나로 통일
   * 다른 말로 표현하자면 URI가 플랫폼 중립적이어야 한다.

## 어떠한 장점이 존재하는가?

1. Open API를 제공하기 쉽다.
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

## 단점은 뭐가 있을까?

1. 사용할 수 있는 메소드가 4가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.



### Reference

* [REST API 제대로 알고 사용하기](https://meetup.toast.com/posts/92)



# 컴파일러 vs 인터프리터

[참고링크]([https://jins-dev.tistory.com/entry/Compiler-%EC%99%80-Interpreter-%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90](https://jins-dev.tistory.com/entry/Compiler-와-Interpreter-의-개념과-차이점))

프로그램 언어를 해석하고 실행시키는 대표적인 방법으로 Compile 과 Interpret 방식이 있다.

Compile 작업은 Compiler 에 의해 실행되고, Interpret 작업은 Interpreter 에 의해 실행되는데, 두 컨셉이 명확하게 다르기 때문에 

많은 프로그래밍 언어들은 둘 중 한가지 방식을 통해 언어를 실행하도록 설계된다. (Java 와 같이 두가지를 모두 채용하는 경우도 있다!)

그렇기 때문에 Compiler 와 Interpreter 를 이해하는 것은 어떤 언어를 배우던지간에 해당 언어의 구동원리를 배울 수 있는 중요한 선행학습이라할 수 있겠다.


**컴파일 (Compile)**

프로그래밍 언어를 Runtime 이전에 기계어로 해석하는 작업 방식이다.
이때 원래의 소스를 원시 코드, 바뀐 코드를 목적 코드(Object Code) 라 한다.

런타임 이전에 Assembly 언어로 변환하기 때문에 구동 시간이 오래걸리지만, 구동된 이후는 하나의 패키지로 매우 빠르게 작동하게 된다.
구동시에 코드와 함께 시스템으로부터 메모리를 할당받으며 할당받은 메모리를 사용하게 된다.

런타임 이전에 이미 해석을 마치고 대게 컴파일 결과물이 바로 기계어로 전환되기 때문에 OS 및 빌드 환경에 종속적이다.
그러므로 OS 환경에 맞게 호환되는 라이브러리와 빌드환경을 구분해서 구축해줘야 한다.

Compile 언어의 대표격으로 C / C++ 와 같은 언어들을 들 수 있으며, Java 역시 Byte Code 로 바꾸기 위한 과정에서 컴파일을 수행한다.


**인터프릿 (Interpret)**

런타임 이전에 기계어로 프로그래밍 언어를 변환하는 컴파일 방식과 다르게, 런타임 이후에 Row 단위로 해석(Interpret) 하며 프로그램을 구동시키는 방식이다.

프로그래밍 언어를 기계어로 바로 바꾸지않고 중간 단계를 거친 뒤, 런타임에 즉시 해석하기 때문에 바로 컴팩트한 패키지 형태로 Binary 파일을 뽑아낼 수 있는 Compile 방식에 비해 낮은 퍼포먼스를 보이게 된다.

런타임에 직접 코드를 구동시키는 특징이 있기 때문에 실제 실행시간은 느리며, 대신 런타임에 실시간 Debugging 및 코드 수정이 가능하다.

또한 메모리를 별도로 할당받아 수행되지 않으며, 필요할 때 할당하여 사용한다. 이와 관련되어 코드의 흐름 자체도 실제 필요할 때, 실제 수행되어야하는 시점에 수행되기 때문에 덕타이핑(Duck Typing) 이 가능한 측면이 있으나, 반대로 정적 분석이 되지않는 Trade off 를 갖고 있다.

 

대표적인 Interpreter 언어로는 Javascript 와 같은 스크립팅 언어들이 있다. 하지만, 스크립트 언어 뿐 아니라 컴파일 이후의 동작에서 Interpret 을 수행하는 언어들도 많이 존재한다.


많은 프로그래밍 언어들의 인터프리터는 해석을 위한 Virtual Machine 을 두고, Machine 위에서 Interpret 을 수행하게 되는데, 이 때 해석의 기반이 되는 머신들이 OS 환경들을 지원해줌으로써, 해당 방식으로 인터프리터는 OS 및 플랫폼 에 종속되지않는 프로그램 구동이 가능하게 된다.
(이런 특징을 지닌 Interpreter 는 Java 의 JVM 과 Python 의 Analyzer 가 있겠다.)


컴파일러와 인터프리터의 차이는 잘 이해하고 언어와 환경을 파악하는데 활용하는 것이 중요하다.



출처: https://jins-dev.tistory.com/entry/Compiler-와-Interpreter-의-개념과-차이점 [Jins' Dev Inside]





# 쿠키, 세션, 캐시

### 1. 쿠키(cookie)

브라우저를 사용하는 환경 (`로컬 컴퓨터`)에 서버에서 받은 데이터를 저장한 파일

1. 로그인 정보 같이 유저가 굳이 다시 서버에 다시 요청하기에는 비효율적인 정보를 로컬에 저장해둠으로서 생산성을 높이는 것이 목적!
2. 로그인 정보 등 사용자의 정보가 저장되는 경우가 많아 보안문제를 잘 살펴야 함.
3. 다시 서버에 request 할 필요가 없기 때문에 속도가 빠름

- 사용 예 : 자동로그인 , 오늘그만보기 팝업창 등

### 2. 세션(session)

`서버`에서 유저의 인증상태 (로그인 여부 등) 을 임시로 저장한 파일

1. 쿠키와 같이 임시로 유저의 정보를 저장해둠으로서 생산성을 높이는 것이 목적!
2. 서버에 저장해두기 때문에 쿠키보다 보안이 우수함.
3. 서버에 저장되어있어서 쿠키보다 다소 느리고 유저정보가 많으면 메모리 과부하가 생길 수 있음.
4. 서버에서 관리하기 때문에 로그관리 용이함.

- 사용 예 : 로그인 한 정보들

### 3. 쿠키와 세션

- 공통점 : 데이터를 임시로 계속 저장해두는 역할.
- 차이점 : 쿠키는 사용자에게 저장되고 세션은 서버에 저장됨.

웹 개발 시 어떤 정보를 쿠키로 저장할 지, 세션으로 저장할 지 적절히 판단하는 것이 중요하다.

### 4. 캐시(cache)

브라우저를 사용하는 환경 (`로컬 컴퓨터`)에 서버에서 받은 데이터를 저장한 파일 (쿠키와동일)

1. 이미지같은 재사용될 것 같거나 용량이 큰 리소스를 임시로 저장해두어서 렌더링 속도를 높이는 것이 목적!
2. 쿠키와는 비슷하지만 목적성에 차이가 있다

[출처]([https://velog.io/@kimtaeeeny/%EC%BF%A0%ED%82%A4cookie-%EC%84%B8%EC%85%98session-%EA%B3%BC-%EC%BA%90%EC%8B%9Ccache-FE-study9](https://velog.io/@kimtaeeeny/쿠키cookie-세션session-과-캐시cache-FE-study9))